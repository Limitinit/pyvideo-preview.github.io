<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="/" rel="alternate"></link><link href="/feeds/speaker_pau-freixes.atom.xml" rel="self"></link><id>/</id><updated>2020-07-23T00:00:00+00:00</updated><entry><title>gRPC Python, C Extensions, and AsyncIO</title><link href="/europython-2020/grpc-python-c-extensions-and-asyncio.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>Lidi Zheng</name></author><id>tag:,2020-07-23:europython-2020/grpc-python-c-extensions-and-asyncio.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;How to make AsyncIO work with the gRPC Core&lt;/p&gt;
&lt;p&gt;Goal - Encourage Python developers to understand C extensions by sharing gRPC Python’s practice, and advocate the adoption of AsyncIO.&lt;/p&gt;
&lt;p&gt;Prerequisite
- Understand thread vs. process;
- Interested in asynchronous programming.&lt;/p&gt;
&lt;p&gt;gRPC Brief
- What’s gRPC Core? And what is gRPC Python?&lt;/p&gt;
&lt;p&gt;Cython To The Rescue
- Why we picked Cython among all other available tools (e.g., pybind11, ctypes)
- Debuggability: pdb &amp;amp; gdb&lt;/p&gt;
&lt;p&gt;The GIL Friction
- How to delegate work to C extension
- How to make multithreading work&lt;/p&gt;
&lt;p&gt;AsyncIO Topic
- Not blocking the loop, the main headache.
- Non-blocking I/O solution 1: replacing C libraries’ I/O operations
- Non-blocking I/O solution 2: dedicated background poller thread
- Performance improvement (10k -&amp;gt; 20k for client, 4k -&amp;gt; 16k for server)&lt;/p&gt;
&lt;p&gt;Migration to AsyncIO
- Tolerate multithreading and AsyncIO in the same application
- Make both API co-existable in the same application&lt;/p&gt;
</summary><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="ASYNC / Concurreny"></category><category term="CPython"></category><category term="Cython"></category><category term="Performance"></category></entry><entry><title>Amqp from Python, advanced design patterns</title><link href="/pycon-es-2015/amqp-from-python-advanced-design-patterns.html" rel="alternate"></link><published>2016-02-02T00:00:00+00:00</published><updated>2016-02-02T00:00:00+00:00</updated><author><name>Pau Freixes</name></author><id>tag:,2016-02-02:pycon-es-2015/amqp-from-python-advanced-design-patterns.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;AMQP as standard application layer protocol is widely used to design backends where business logic is spread around different processes using a broker to link them, usually RabbitMQ. AMQP allows us to use different design patterns than the traditional monolithic backends, where part of your business logic is designed as entities of the AMQP topology. In this talk we will talk about the Python drivers such as Celery, Pika and others, and how they can be used to get the full power of the AMQP.&lt;/p&gt;
</summary><category term="Track Avanzado"></category></entry></feed>