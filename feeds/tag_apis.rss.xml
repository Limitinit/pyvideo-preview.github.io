<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>/</link><description></description><lastBuildDate>Thu, 23 Jul 2020 00:00:00 +0000</lastBuildDate><item><title>Desenvolvendo APIs REST com Python 3 e Asyncio</title><link>/caipyra-2016/desenvolvendo-apis-rest-com-python-3-e-asyncio.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Palestra do Renato Garcia no Caipyra 2016:&lt;/p&gt;
&lt;p&gt;Desenvolvendo APIs REST com Python 3 e Asyncio&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Renato Garcia</dc:creator><pubDate>Sun, 26 Jun 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2016-06-26:caipyra-2016/desenvolvendo-apis-rest-com-python-3-e-asyncio.html</guid><category>api</category><category>apis</category><category>rest</category><category>rest api</category><category>asyncio</category><category>async</category></item><item><title>Don't start with a database</title><link>/europython-2019/dont-start-with-a-database.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What you do when you start a new project? Usually, we begin with
database design, then we prepare a migration system, user registration,
and all different stuff that distracts us from doing what is most
important - business logic. With the clean architecture, we can learn
how to start a project in another way and this will be one of two main
topics of my talk. The second one will be about new features in Python.
You probably heard about typings, mypy, and dataclasses, but I will show
you how they can be used in real life project that can be developed over
many years in production lifecycle. There will be no &amp;quot;hello world&amp;quot; app,
no copy &amp;amp; paste of documentation, only practical knowledge learned
through many years of practice.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Grzegorz Kocjan</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2019-07-12:europython-2019/dont-start-with-a-database.html</guid><category>APIs</category><category>Abstractions</category><category>Architecture</category><category>Best Practice</category><category>Clean Code</category></item><item><title>How we run GraphQL APIs in production on our Kubernetes cluster</title><link>/europython-2019/how-we-run-graphql-apis-in-production-on-our-kubernetes-cluster.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk I would like to share the workflow and tools we use to
build, deploy and operate GraphQL APIs on our on-premise Kubernetes
cluster.&lt;/p&gt;
&lt;p&gt;I will share code and command examples explaining how we are operating
our applications since our recent transition from REST APIs on Web
servers to GraphQL APIs containers on Kubernetes.&lt;/p&gt;
&lt;p&gt;This talk will not be about the difference between REST and GraphQL but
focus on the workflow, tools and experience we gained in switching our
run time environments and API models.&lt;/p&gt;
&lt;p&gt;At Numberly, we have built and are operating our own on-premise
Kubernetes cluster so we will also be talking about its capabilities and
share some of the experience we gained in doing so.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Proposed agenda:&lt;/div&gt;
&lt;div class="line"&gt;- Our previous workflow and its limitations&lt;/div&gt;
&lt;div class="line"&gt;- How we designed our Kubernetes cluster, its capabilities and the
choices we made&lt;/div&gt;
&lt;div class="line"&gt;- Developer workflow, environments management and deployment&lt;/div&gt;
&lt;div class="line"&gt;- Our GraphQL stack, featuring a sample application&lt;/div&gt;
&lt;div class="line"&gt;- What we're still working on to improve&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexys Jacob</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2019-07-12:europython-2019/how-we-run-graphql-apis-in-production-on-our-kubernetes-cluster.html</guid><category>APIs</category><category>Best Practice</category><category>Case Study</category><category>Docker</category><category>Infrastructure</category></item><item><title>Deploy Python to the cloud faster with Azure Serverless</title><link>/europython-2019/deploy-python-to-the-cloud-faster-with-azure-serverless.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Bringing your Python scripts or apps and running them in the cloud is
easier than ever with serverless computing. In this talk, we’ll show how
you can use Azure Functions to easily deploy and scale your Python
workloads without having to manage any servers or pay for unused compute
resources. We’ll also show how deep integration with Visual Studio Code
offers a great local development experience with full support for
debugging and testing your app, and allows you to seamlessly deploy your
serverless code to the cloud.&lt;/p&gt;
&lt;p&gt;We’ll start by giving a brief overview of the value of serverless
computing. Next, we'll create a brand new Python app in Visual Studio
Code, and start to add in business logic and ML capabilities. Once we
get the app running debugged locally, we’ll publish it to the cloud as a
serverless function, and demonstrate the serverless scalability.
Finally, we’ll walk you through the tools and capabilities you can
leverage around monitoring and management of your Python Azure
Functions.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeff Hollan</dc:creator><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2019-07-11:europython-2019/deploy-python-to-the-cloud-faster-with-azure-serverless.html</guid><category>APIs</category><category>Development</category><category>Microservices</category><category>Scaling</category><category>Tooling</category></item><item><title>API-schema-based testing with schemathesis</title><link>/europython-2020/api-schema-based-testing-with-schemathesis.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Automatically generate test-cases based on your API-schemas.&lt;/p&gt;
&lt;p&gt;The goal with this talk is to introduce the audience to property-based testing for API’s using schemas to automatically generate test scenarios, enabling them to write more powerful tests faster.&lt;/p&gt;
&lt;p&gt;The talk will focus on a subset of the field of property-based testing where we focus on testing by automatically generating properties and test strategies from the API Schemas that we often already have. These tests ensure that our APIs conform to their specified schema and enables us to write a much larger amount of tests in less time.&lt;/p&gt;
&lt;p&gt;I will focus on the schemathesis library which leverages the strong hypothesis library as well as the hypothesis-JSONSchema extension strategies, and will in the future also support GraphQL via the hypothesis-graphql strategies. I’m a contributor to schemathesis and currently working on the future GraphQL support with schemathesis creator, Dmitry Dygalo.&lt;/p&gt;
&lt;p&gt;I will also compare it with its predecessor “swagger-conformance”, pure property-based testing through hypothesis, schema strategies with hypothesis-graphql and hypothesis-jsonschema, and discuss their advantages and disadvantages. I will also briefly talk about “QuickREST: Property-based Test Generation of OpenAPI-Described RESTful APIs” (&lt;a class="reference external" href="https://arxiv.org/abs/1912.09686"&gt;https://arxiv.org/abs/1912.09686&lt;/a&gt;), the research paper that’s part of the inspiration for these tools.&lt;/p&gt;
&lt;p&gt;By focusing on property-based test generation using schemas we already have, I will show that a field like property-based testing, which can seem quite daunting at first, actually can have a low barrier to entry while yielding large amounts of value in return and is useful for most common web projects today.&lt;/p&gt;
&lt;p&gt;The talk will show how formal schemas for APIs can and will continue to provide additional value outside the scope of documentation.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Hultnér</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/api-schema-based-testing-with-schemathesis.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>RESTful</category><category>Test Libraries (pytest/nose/...)</category><category>Testing</category><category>Web Servers and MicroFWs (Flask/Tornado/Nginx/...)</category></item><item><title>Developing GraphQL API in Django using Graphene</title><link>/europython-2020/developing-graphql-api-in-django-using-graphene.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Build GraphQL schema, queries, and mutations in Django using graphene library&lt;/p&gt;
&lt;p&gt;GraphQL technology has become popular nowadays. While developing REST APIs, there are many things that developers need to take into consideration. There are multiple endpoints and over-fetching is the main problem of REST. GraphQL offers a unique approach and architecture for developing APIs. How is that efficient?&lt;/p&gt;
&lt;p&gt;While using GraphQL, a client can request the data which is needed. It is an alternative for building APIs in place of REST. It’s a query language that can work as a medium between the frontend and backend.&lt;/p&gt;
&lt;p&gt;The journey to develop GraphQL APIs in python needs some requirements and knowledge. We will be building APIs in the Django framework using a graphene library which includes many features of GraphQL such as ObjectTypes, Queries, Mutations, etc. We will start by understanding these concepts followed by some code. This includes detailed information about the Query class, what are resolvers, and where to write business logic, how pagination can be incorporated with queries would be included. Also, it will include the information about the Mutation class, arguments needed for mutation, and what type of response can be returned on successful operations.&lt;/p&gt;
&lt;p&gt;Learning outcomes would be the understanding of code and building GraphQL APIs using graphene in a proper and structured way.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Nisarg Shah</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/developing-graphql-api-in-django-using-graphene.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Databases</category><category>Django</category><category>PostgreSQL</category><category>Python 3</category></item><item><title>Extending HTTP for fun and non-profit</title><link>/europython-2020/extending-http-for-fun-and-non-profit.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;My journey into the IETF HTTP workgroup&lt;/p&gt;
&lt;p&gt;Writing API guidelines is a best practice for standardizing APIs produced by thousands of service provider, but what happens when those rules are not backed by internet standards?&lt;/p&gt;
&lt;p&gt;This talk proposes an iterative strategy for identify and standardize inside IETF key features of your API guidelines.
The steps includes feature landscaping, stakeholder identification and engagement, prototyping and writing an actual internet-draft.&lt;/p&gt;
&lt;p&gt;The strategy is shown using two examples:
- rewriting of &lt;cite&gt;Digest&lt;/cite&gt; header RFC3230 adding clarifications useful for implementors;
- proposing new &lt;cite&gt;RateLimit&lt;/cite&gt; headers and engage with implementors (Microsoft, Red Hat, Kong, ..).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Roberto Polli</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/extending-http-for-fun-and-non-profit.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Best Practice</category><category>Case Study</category><category>Community</category><category>HTTP</category></item><item><title>Full Stack Type Safety</title><link>/europython-2020/full-stack-type-safety.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Beyond PEP-484 – ensure type consistency between layers&lt;/p&gt;
&lt;p&gt;The introduction of PEP-484 gave us an option to enforce the internal type consistency of our Python applications. Our web projects, however, consist of multiple layers, with the Python app taking the role of an HTTP backend. What options do we have to ensure consistency across our stack?
In this talk, we will see some technologies that we can employ to enforce the contract between the layers of our stack. Especially between the frontend and backend. We will demo, how this can be achieved with REST/Swagger and with GraphQL. As both the Graphene library and the open API support for django-rest-framework are both a work-in-progress, we would check, what is possible, and what is still lacking. We will also discuss various approaches to the design: backend first, auto-generating backend from the spec, and TDD, with their advantages and disadvantages.
The topic would be discussed on a simple web application. We would try to play some realistic scenarios, where a careless developer breaks the contract to see how such a mistake can be spotted in the CI phase of the development cycle.
Basic knowledge of Django and JavaScript is required to understand the talk. Some familiarity with TypeScript and ReactJS would also be helpful. However, I plan to explain the code to the listeners that didn’t have prior exposure to these technologies.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Szymon Pyżalski</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/full-stack-type-safety.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Django</category><category>JavaScript</category><category>Type-Hinting</category><category>Web Protocols</category></item><item><title>How to be Pythonic? Design a Query Language in Python</title><link>/europython-2020/how-to-be-pythonic-design-a-query-language-in-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Query language is an important part of a database system, it is how people manage their data and how they can make the data useful to them. Starting from the 70s, the world is full of relational databases and SQL was the way to make queries. However, SQL is valuable to an injection attack. Lots of efforts are being used to stop those attacks and it made workflow become less efficient.&lt;/p&gt;
&lt;p&gt;We don’t want to make the same mistake. That’s why using a Python query language is good. Having the Python community in our mind, we created WOQLpy, an open-source query language that lets users build queries in Python, instead of JSON-LD which is the native query language for our TerminusDB database. Now users can store data with a knowledge graph and make graph data visualization with Python.&lt;/p&gt;
&lt;p&gt;In the first part of the talk, we will talk about what challenges we have when creating a query language in Python, the method we use, the idea and theory behind, and how WOQLpy work. This part will include a quick live demo of using WOQLpy so audiences can have an impression on how to make a query and get the task done, that is, getting a meaningful graph visualization form the source CSVs. The process of how to create a database and schema, loading the data form many CSVs, making a query and visualization, will be demonstrated using just one python script.&lt;/p&gt;
&lt;p&gt;In the second part of the talk, we want to stimulate a discussion of what is a good design in Python and what is not. This part will be more interactive with the audiences, as we want to hear from you all, what would be the best for Pythonistas. By first suggesting some possible design, we will use a live voting system to gather opinions. This part of the talk will extend to the Q &amp;amp; A sessions to allow further discussions.&lt;/p&gt;
&lt;p&gt;This talk is for Pythonista at all levels who are interested in starting to design a package in Python, no matter if the audience has published a python library or not. By attending this talk, audiences will learn about how to design a Python package that will be useful to Pythonistas and hopefully encourage more people to publish open-source packages online.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Cheuk Ho</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/how-to-be-pythonic-design-a-query-language-in-python.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Databases</category><category>Graph Databases</category><category>Open-Source</category><category>Programming</category></item><item><title>Overcoming access control in web APIs</title><link>/europython-2020/overcoming-access-control-in-web-apis.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;How to address security concerns using Sanic&lt;/p&gt;
&lt;p&gt;Great, you've developed a great web API. Awesome, you are about to deploy it. But, how do you secure it and manage access?&lt;/p&gt;
&lt;p&gt;Learn about different approaches to securing a web API whether it is meant for third-party integrations or driving a modern single-page application. Not all APIs are the same, so we will explore different considerations to make when crafting a solution to handle token-based authentication, and scoping to define access levels.&lt;/p&gt;
&lt;p&gt;As one of the core developers of the async web framework Sanic, I will primarily focus on authentication and authorization tools inside Sanic to showcase how to address these issues. However, the concepts should be broadly applicable enough to take back and apply to any web API. The goal is to learn the hot spots, and identify strategies to overcome them.&lt;/p&gt;
&lt;p&gt;Core take aways will include:
- how to implement various JWT strategies;
- best practices for storing JWTs on a browser; and
- controlling access privileges using structured scopes.&lt;/p&gt;
&lt;p&gt;Time permitting, we will even discuss some tools to be used to help ease the anxiety and make security more approachable.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Adam Hopkins</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/overcoming-access-control-in-web-apis.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Authentication</category><category>Best Practice</category><category>RESTful</category><category>Web</category></item><item><title>ScanAPI</title><link>/europython-2020/scanapi.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Automated Integration Testing and Live Documentation for your API&lt;/p&gt;
&lt;p&gt;In the current IT scenario, the use of APIs is, without question, widely vast, popular, and significant. It seems at least prudent to ensure they are working properly, as expected. To guarantee the quality of the data that is being consumed or used. To ensure that communication between services is occurring as expected. To ensure the system does, in fact, what it should do.&lt;/p&gt;
&lt;p&gt;ScanAPI is an open-source library that was created to solve all these points. ScanAPI provides an easy way to create integration tests for REST APIs via configuration files.&lt;/p&gt;
&lt;p&gt;The three main reasons that led me to the creation of this library were:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;To be a firefighter in a scenario where most of the reported bugs were directly related to some API contract being broken or some endpoint having a behavior different from that expected by the consumer.&lt;/li&gt;
&lt;li&gt;To need to deal with APIs with outdated or mistaken documentation.&lt;/li&gt;
&lt;li&gt;To need to debug an endpoint in the middle of a &amp;quot;chain&amp;quot; of other endpoints. Where I needed to recreate a state that depends on the action of other endpoints.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given a fictitious example: debug an endpoint to reserve seats on an airplane, which depends directly on the previous call of an endpoint for user registration.&lt;/p&gt;
&lt;p&gt;The ScanAPI is open-source and written in Python. However, it can be used in APIs created in any other programming language, since the tests provided by it are integration tests.&lt;/p&gt;
&lt;p&gt;With ScanAPI you can:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use environment variables&lt;/li&gt;
&lt;li&gt;Create variables&lt;/li&gt;
&lt;li&gt;Chaining requests - making a request from a result of previous responses&lt;/li&gt;
&lt;li&gt;Hide sensitive information of the requests and responses in the generated report&lt;/li&gt;
&lt;li&gt;Write Python code - if you want, it's not necessary :)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Topics I intend to address in this talk:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Motivation to create the library&lt;/li&gt;
&lt;li&gt;What problems the library solves&lt;/li&gt;
&lt;li&gt;How to test an API using a ScanAPI&lt;/li&gt;
&lt;li&gt;Show the documentation generated by ScanAPI&lt;/li&gt;
&lt;li&gt;An overview of how it is implemented&lt;/li&gt;
&lt;li&gt;Where it is currently being used&lt;/li&gt;
&lt;li&gt;Next steps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Project Link: &lt;a class="reference external" href="https://github.com/scanapi/scanapi"&gt;https://github.com/scanapi/scanapi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prerequisites:
- Python
- REST APIs
- Integration tests&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Camila Maia</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2020-07-23:europython-2020/scanapi.html</guid><category>europython</category><category>europython-2020</category><category>europython-online</category><category>APIs</category><category>Open-Source</category><category>RESTful</category><category>Test Libraries (pytest/nose/...)</category><category>Testing</category></item><item><title>Using Python, Django, and ruthlessness to protect people from social media harassment.</title><link>/kiwi-pycon-2019/using-python-django-and-ruthlessness-to-protect-people-from-social-media-harassment.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk, I present 'secateur', a tool for Twitter users to protect themselves from some forms of online harassment. I discuss using Python and Django to create tools that integrate with Twitter, use its APIs, and block lots of people (LOTS of people).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Tom Eastman</dc:creator><pubDate>Sat, 24 Aug 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2019-08-24:kiwi-pycon-2019/using-python-django-and-ruthlessness-to-protect-people-from-social-media-harassment.html</guid><category>twitter</category><category>APIs</category><category>secateur</category><category>django</category></item><item><title>PyConAU 2010: Building the Wave Robots API: Behind the Scenes</title><link>/pycon-au-2010/pyconau-2010--building-the-wave-robots-api--behin.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Building the Wave Robots API: Behind the Scenes&lt;/p&gt;
&lt;p&gt;Presented by Pamela S Fox (Google)&lt;/p&gt;
&lt;p&gt;The Google Wave robots protocol involves JSON-RPC messages that are sent
between the Wave server and the robot, communicating events to process
and operations to perform. The Python Robots API abstracts on top of
that JSON-RPC service, allowing developers to interact with waves using
event callbacks, python classes, and chained functions. In this talk,
we'll explain the JSON- RPC protocol, talk about how we designed the API
to sit on top of that protocol, and show how developers can use the API.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Pamela S Fox</dc:creator><pubDate>Sat, 26 Jun 2010 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2010-06-26:pycon-au-2010/pyconau-2010--building-the-wave-robots-api--behin.html</guid><category>apis</category><category>json</category><category>jsonrpc</category><category>pyconau</category><category>pyconau2010</category><category>web</category></item><item><title>Django APIs, Versioning and You</title><link>/pycon-ireland-2018/django-apis-versioning-and-you.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk will attempt to explain how to version an API within the Django framework. Say you need to change the data that your API returns to your users, but any major changes would result in breaking the API for users of any previous versions. This talk will explain how to avoid this problem, which as a developer who works on APIs with the Django framework every day is a constant problem that I would have to face. This talk will cover: 1.) Why do I even have to version my API in the first place? Surely I can just make changes? 2.) Okay, now I understand why to version my API in Django. What about the how? (this will mainly focus on the Django REST framework's library of versioning, but other methods will be considered) 3.) Live Demo of breaking changes (oh no!) and how we can apply our knowledge from the second part of the talk and avoid these.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rebecca Martin</dc:creator><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2018-11-10:pycon-ireland-2018/django-apis-versioning-and-you.html</guid><category>django</category><category>APIs</category></item><item><title>Machine Learning by Example</title><link>/pytexas-2019/machine-learning-by-example.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Imagine you could easily use ML without having a PhD or having to mess with models or interacting with TensorFlow? Imagine ML working for your application, not you working for ML. In this session learn how to use ML APIs through demos to power your application and focus on what matters!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gabriela D'Ávila Ferrara</dc:creator><pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:,2019-04-13:pytexas-2019/machine-learning-by-example.html</guid><category>machine learning</category><category>APIs</category></item></channel></rss>